# 设计模式开篇



## 定义

设计模式是一套代码设计经验的总结，使用目的是为了可重用代码、让代码更容易理解和修改，提高代码的可靠性。

> **设计模式的作用**：软件设计是复杂的，其根本原因在于设计中需要考虑多种变化因素，例如需求的变化、平台的变化等。不好的代码设计会导致微小的需求变化引起大幅的代码改动。我们往往无法消灭这些变化，也就是说代码的更动是必然的，但是我们有机会通过遵循一些设计原则、使用一些良好的设计模式来使**变化向某个局部集中**，这样就增强了代码的可维护性。可以说，**设计模式的目标就是复用**。



## 抽象

抽象是设计模式中的核心手段。

人们解决问题复杂性的方法通常有**分解**和**抽象**两种方法。

前一种，就如mainForm1.cpp和shape1.h中的示例，当一个新的需求到来时，将该需求的实现分别插入到项目代码中的各个部分：在shape1.h中新建一个圆类，在mainForm1.cpp中添加相应vector和相应的paint，以及增加一个if判断分支。当项目足够的庞大时，通过分解法新增一个需求的实现往往要改动上百处，很容易产生“漏网之鱼”。

**抽象，意在使用通用方法统一处理需求，多态是其中一项很重要的技术**。如mainForm2.cpp和shape2.h所示的那样，我们建立了Shape基类，并使得mainForm2.cpp几乎都基于Shape这个抽象类来构建代码（尽管newShape中还依赖于具体类，但是利用后续的设计模式可以进行解决），mainForm2.cpp近乎稳定。面对新需求，我们只要做的就是写个派生类,以及增加一个if判断分支。



## 学习建议

每一种设计模式都包含四个要素：模式名称、问题、解决方案和效果。学习一种模式就是要掌握这四种要素：

+ **问题**：必须清楚这个设计模式旨在解决一个什么问题，明确什么时候可以使用它。
+ **解决方案**：如何解决问题，借助UML结构图来理解，记住它的关键代码。
+ **效果**：明白这个模式的优缺点，注意事项，在实际使用中做到利弊权衡。

除此之外，还有一些学习方法：

+ **最重要的不是设计模式本身，而是设计原则**，完全理解了这些原则，就能做到“手中无模式，心中有模式”。
+ 对比模式应用前后的代码，**找出稳定和变化的部分**。
+ 不断练习与应用。





## 类间关系和UML表示



### 关联关系

关联用于表示一类对象与另一类对象之间有联系，这种联系通常表现为整体与部分的关系。在编程实现上，通常是**将一个类的对象作为另一个类的成员变量**。在UML类图中，关联关系用实线连接表示。

关联关系在方向性上可分为：单向关联、双向关联和自关联；在关系程度上可分为：聚合关系和组合关系。



#### 单向关联

顾客拥有地址可以用单向关联表示。

![](https://gitee.com/KenSporger/typera-picgo/raw/master/img/image-20211207160740656.png)

#### 双向关联

顾客购买商品并拥有商品，同时，卖出的商品属于该顾客。这个关系可以用双向关联表示。

![](https://gitee.com/KenSporger/typera-picgo/raw/master/img/image-20211207161401434.png)



#### 自关联

链表可以通过节点类的自关联来表示。

![](https://gitee.com/KenSporger/typera-picgo/raw/master/img/image-20211207161630468.png)




#### 聚合关系

在聚合关系中，成员对象可以脱离整体对象独立存在。例如，汽车发动机是汽车的一部分，但是可以独立存在。在代码实现聚合关系时，**成员对象通常作为构造方法、Setter方法或业务方法的参数注入到整体对象中**。

![](https://gitee.com/KenSporger/typera-picgo/raw/master/img/image-20211207162246725.png)



#### 组合关系

和聚合关系相反，在组合关系中，整体对象控制成员对象的生命周期，一旦整体对象不存在，成员对象也将不存在。例如，点是线段的组成部分，如果线段没了，点就不能存在。在代码实现组合关系时，**通常在整体类的构造方法中直接实例化成员类**。

![](https://gitee.com/KenSporger/typera-picgo/raw/master/img/image-20211207163439669.png)



### 依赖关系

依赖关系是一种使用关系，大多数时候体现在**一个类对象方法使用另一个类对象的方法**。在代码实现上，依赖关系有三种方式：

+ 将一个类的对象作为另一个类中方法的参数；
+ 一个类的方法中将另一个类的对象作为其局部变量；
+ 在一个类的方法中调用另一个类的静态方法；

![](https://gitee.com/KenSporger/typera-picgo/raw/master/img/image-20211207164333222.png)



### 继承关系

描述父类与子类之间的关系。在UML类图中，派生类只需要写出新增的成员对象和方法。

![](https://gitee.com/KenSporger/typera-picgo/raw/master/img/image-20211207164910146.png)



### 实现关系

接口之间也可以有继承和依赖关系，但是接口和类之间还存在一个种实现关系。在UML中，类需要再写一遍所实现的接口方法。

![image-20211207165355069](https://gitee.com/KenSporger/typera-picgo/raw/master/img/image-20211207165355069.png)




## 六大设计原则

### 开闭原则 

+ 对扩展开放，对更改封闭
+ 应通过扩展的方式适应新的需求（例如增加一个Circle的派生类）


### 依赖倒置原则

+ 高层模块（稳定的）不依赖底层模块（变化的），二者都依赖抽象（稳定的，接口）。（例如Shape抽象类）
+ 抽象不依赖实现细节（变化的），细节依赖抽象。（虚函数继承）

### 里氏代换原则

+ 子类能够替换其父类
+ 指明了A类什么情况下可以继承B类（A is B） 

### 单一职责原则

+ 一个类应只有一个引起它变化的原因
+ 一个类不能具备很多职责，否则耦合程度太高

### 接口隔离原则

+ 不应该“强迫”客户程序依赖他们不用的方法
+ 接口应该小而完备
+ 指明了成员函数应该是public还是private的问题

### 封装变换点

+ 使用封装来创建对象之间的分界层，一边是稳定的部分，另一边是变化的部分

### 优先使用对象组合，而不是类继承

+ 继承：将父类的全部内容暴露给子类
+ 对象组合：只暴露想暴露的部分，其余的内容对其类不可见
+ 继承在某种程度上破坏了封装性,子类父类耦合度高
+ 对象组合则只要求被组合的对象具有良好的定义的接口

### 针对接口编程，而不是针对实现编程

+ 不将变量类型声明为某个特定类型的具体类，而是声明为某个接口（例如mainForm2.cpp中声明Shape*）