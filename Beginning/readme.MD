## 设计模式开篇



### 为什么软件设计是复杂的  

根本原因在于软件设计中需要考虑多种变化因素，例如需求的变化、平台的变化等。不好的设计模式会导致微小的需求变化引起大幅的代码改动。

### 设计模式的作用  

我们往往无法消灭变化，也就是说代码的更动是必然的，但是我们有机会通过遵循一些设计原则、使用一些良好的设计模式来使**变化向某个局部集中**，这样就增强了代码的可维护性。可以说，**设计模式的目标就是复用**。

### 抽象的意义

人们解决问题复杂性的方法通常有**分解**和**抽象**两种方法。

前一种，就如mainForm1.cpp和shape1.h中的示例，当一个新的需求到来时，将该需求的实现分别插入到项目代码中的各个部分：在shape1.h中新建一个圆类，在mainForm1.cpp中添加相应vector和相应的paint，以及增加一个if判断分支。当项目足够的庞大时，通过分解法新增一个需求的实现往往要改动上百处，很容易产生“漏网之鱼”。

**抽象，意在使用通用方法统一处理需求，多态是其中一项很重要的技术**。如mainForm2.cpp和shape2.h所示的那样，我们建立了Shape基类，并使得mainForm2.cpp几乎都基于Shape这个抽象类来构建代码（尽管newShape中还依赖于具体类，但是利用后续的设计模式可以进行解决），mainForm2.cpp近乎稳定。面对新需求，我们只要做的就是写个派生类,以及增加一个if判断分支。

### 如何学习设计模式

+ **最重要的不是设计模式本身，而是设计原则**，一个好的模式是基于原则设计出来的
+ 了解每一个设计模式是为了**解决实际项目中哪些问题的需要**
+ 对比模式应用前后的代码，**找出稳定和变化的部分**


### 六大设计原则

#### 开闭原则 

+ 对扩展开放，对更改封闭
+ 应通过扩展的方式适应新的需求（例如增加一个Circle的派生类）


#### 依赖倒置原则

+ 高层模块（稳定的）不依赖底层模块（变化的），二者都依赖抽象（稳定的，接口）。（例如Shape抽象类）
+ 抽象不依赖实现细节（变化的），细节依赖抽象。（虚函数继承）

#### 里氏代换原则

+ 子类能够替换其父类
+ 指明了A类什么情况下可以继承B类（A is B）

#### 单一职责原则

+ 一个类应只有一个引起它变化的原因
+ 一个类不能具备很多职责，否则耦合程度太高

#### 接口隔离原则

+ 不应该“强迫”客户程序依赖他们不用的方法
+ 接口应该小而完备
+ 指明了成员函数应该是public还是private的问题

#### 封装变换点

+ 使用封装来创建对象之间的分界层，一边是稳定的部分，另一边是变化的部分

#### 优先使用对象组合，而不是类继承

+ 继承：将父类的全部内容暴露给子类
+ 对象组合：只暴露想暴露的部分，其余的内容对其类不可见
+ 继承在某种程度上破坏了封装性,子类父类耦合度高
+ 对象组合则只要求被组合的对象具有良好的定义的接口

#### 针对接口编程，而不是针对实现编程

+ 不将变量类型声明为某个特定类型的具体类，而是声明为某个接口（例如mainForm2.cpp中声明Shape*）